#!/bin/sh

# Quit if a valid configuration source doesn't exist
[ -f "$XDG_CONFIG_HOME/shortcutrc" ] && src="$XDG_CONFIG_HOME/shortcutrc" || exit 1

# Environment variables with /dev/null defaults
awk -v lf_filepath="${SHORTCUTGEN_LF_FILE:-/dev/null}" \
  -v gtk_filepath="${SHORTCUTGEN_GTK_FILE:-/dev/null}" \
  -v zsh_filepath="${SHORTCUTGEN_ZSH_FILE:-/dev/null}" \
  -v env_filepath="${SHORTCUTGEN_ENV_FILE:-/dev/null}" \
  -v misc_lua_filepath="${SHORTCUTGEN_LUA_FILE:-/dev/null}" \
  -v plain_filepath="${SHORTCUTGEN_TXT_FILE:-/dev/null}" \
  -v json_filepath="${SHORTCUTGEN_JSON_FILE:-/dev/null}" \
  '
BEGIN {
  FS=","
  OFS=","
  max_length = 0
}

# Function to remove whitespaces from a string
function remove_whitespace(str) {
  gsub(/[[:space:]]/, "", str)
  return str
}

# Function to expand ~ into full path (ex: /home/...)
function fullpath(str) {
  gsub(/~\//, ENVIRON["HOME"] "/", str)
  return str
}

{
  # Remove comments
  gsub(/#.*/, "")

  # Remove whitespaces from column 2
  $2 = remove_whitespace($2)

  # Remove leading and trailing whitespaces from column 3
  gsub(/^[[:space:]]+|[[:space:]]+$/, "", $3)

  # whenever a line contains only commas, replace it with an empty string
  # so that we can check if a line is empty or not
  gsub(/^,+$|^,+|,+$|,+,/, "", $0)

  # Check if line is empty or contains only whitespace
  if (NF) {
    # Update max_length if current lhs is longer
    if (length($1) > max_length) {
      max_length = length($1)
    }

    # Store the current line for later processing
    lines[NR] = $0
  }
}
END {
  # Prep for nvim-dropsites:
  print "return {" > misc_lua_filepath

  # Start JSON file
  print "[" > json_filepath

  first_json_entry = 1

  for (i = 1; i <= NR; i++) {
    split(lines[i], fields, FS)

    # Skip processing if necessary fields are empty
    if (fields[2] == "" || fields[3] == "") {
      continue
    }

    # Convert column 2 to lowercase
    lc_col2 = tolower(fields[2])

    # Convert column 2 to uppercase
    uc_col2 = toupper(fields[2])

    # Write to $XDG_CONFIG_HOME/lf/shortcuts
    print "map g" lc_col2 " cd " fields[3] > lf_filepath

    # Write to $XDG_CACHE_HOME/zsh-shortcuts
    print "g" lc_col2 "() {cd " fields[3] "}" > zsh_filepath

    # Write to $XDG_CACHE_HOME/env-shortcuts
    print "export G" uc_col2 "=" fields[3] "" > env_filepath

    # Write to $XDG_CONFIG_HOME/gtk-3.0/bookmarks
    print "file://" fullpath(fields[3]) " " fields[1] > gtk_filepath

    # Write to $XDG_CACHE_HOME/nvim-dropsites
    split(lines[i], fields, FS)
    if (fields[1] != "" && fields[3] != "") {
      printf "{ name = \"%s\", dir = \"%s\", keys = \"%s\" },\n", fields[1], fullpath(fields[3]), lc_col2 >> misc_lua_filepath
    } else if (fields[3] != "") {
      printf "{ name = \"\", dir = \"%s\", keys = \"%s\" },\n", fullpath(fields[3]), lc_col2 >> misc_lua_filepath
    }

    # Write to JSON file
    if (first_json_entry) {
      first_json_entry = 0
    } else {
      printf ",\n" >> json_filepath
    }
    printf"  {\"name\":\"%s\",\"path\":\"%s\",\"key\":\"%s\"}",fields[1],fullpath(fields[3]),lc_col2>>json_filepath

    # Write plain Title + `,` + only if fields[1] is not empty
    if (fields[1] != "") {
      printf "%-*s : %s\n", max_length, fields[1], fullpath(fields[3]) > plain_filepath
    } else if (fields[3] != "") {
      printf "%s\n", fullpath(fields[3]) > plain_filepath
    }
  }

  # Closure for nvim-dropsites:
  print "}" >> misc_lua_filepath

  # Closure JSON file
  print "\n]" >> json_filepath
}
' "$src"
